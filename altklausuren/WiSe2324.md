Klausur WiSe23/24

1. Fragen zur Vorlesung (18 Punkte)
(a) (2 Punkte) Was ist der Unterschied zwischen var und val in Scala?
(b) (2 Punkte) Was ist der Unterschied zwischen private und protected?
(c) (2 Punkte) Was ist der Unterschied zwischen Int und Long?
(d) (3 Punkte) Was ist der dynamische Typ von x in der folgenden Deklaration? Warum kann bei ArraySeq der Typ-Parameter weggelassen werden?
val x: Iterable[Int] = ArraySeq()
(e) (3 Punkte) Der folgende Code-Ausschnitt führt zu einem Kompilierfehler. Warum?
val x: Any = Seq(42, 1337)
println(x.size)
(f) (3 Punkte) Der folgende Code-Ausschnitt führt zu einem Kompilierfehler. Warum?
class Exam(val year: Int, val repetition: Int, val subject: String)
val latestExam = Seq(
Exam(2010, 0, "EIP"),
Exam(2012, 1, "EIP"),
Exam(2011, 0, "EIS")).max
(g) (3 Punkte) Der Trait Iterator[A] ist folgendermaßen in der Scala-Standardbibliothek
definiert. Warum wird die Methode next() mit leeren Klammern deklariert, die
Methode hasNext aber nicht?
trait Iterator[A] {
/** Check if there is a next element available. */
def hasNext: Boolean
/** Return the next element and advance the iterator. */
def next(): A
}

2. Operationen auf Bankdaten (25 Punkte)
Der folgende Scala-Code zeigt zwei einfache Case-Classes, die die gespeicherten Da-
ten eines Überweisungssystems repräsentieren. BankData speichert die Kontostände al-
ler Nutzer und die Abfolge aller bisherigen Transaktionen. Jede Transaktion speichert
Sender, Empfänger, und den überwiesenen Betrag.
/** Eindeutiger Nutzername */
type User = String
/** Transaktion zwischen zwei Nutzern
*
* @param from der sendende Nutzer
* @param to der empfangende Nutzer
* @param amount der Betrag, der gesendet wird
* @throws IllegalArgumentException wenn der Betrag negativ ist oder
* Sender und Empfänger identisch sind
*/
case class Transaction(from: User, to: User, amount: Long) {
if (amount <= 0) throw IllegalArgumentException("amount cannot be negative")
if (from == to) throw IllegalArgumentException("from and to must be different")
}
/** Kontoinformationen für alle Nutzer
*
* @param balances die aktuellen Kontostände aller Nutzer
* @param transactions die Abfolge von Transaktionen,
* die bisher stattgefunden haben, zeitlich sortiert
*/
case class BankData(balances: Map[User, Long], transactions: ArraySeq[Transaction])
Vervollständigen Sie die folgenden Methoden anhand der Beschreibung. Alle Metho-
den sind außerhalb einer Klasse definiert, sie gehören also nicht zu BankData oder
Transaction

(a) (3 Punkte) getBalance gibt den Kontostand des übergebenen Nutzers zurück. Wenn
der Nutzer keinen bekannten Kontostand hat, soll eine IllegalArgumentException
geworfen werden.
def getBalance(user: User, data: BankData): Long =
(b) (4 Punkte) suspiciousPayments gibt alle Nutzer zurück, die 10000 oder mehr
Geldeinheiten in einer einzigen Transaktion gesendet haben. Der Rückgabewert
darf Nutzernamen auch mehrfach enthalten.
def suspiciousPayments(data: BankData): Iterable[User] =
(c) (5 Punkte) totalReceived gibt zurück, wie viele Geldeinheiten ein einzelner Nutzer insgesamt durch eingehende Transaktionen erhalten hat. Diese Zahl entspricht nicht notwendigerweise dem Kontostand des Nutzers!
def totalReceived(user: User, data: BankData): Long =

d) (6 Punkte) richest wählt aus den übergebenen Nutzern den Nutzernamen aus,
dessen Konto den höchsten Kontostand hat. Wenn ein übergebener Nutzer keinen
bekannten Kontostand hat, soll der Nutzer ignoriert werden. Wenn es mehrere
Nutzer mit dem höchsten Kontostand gibt, soll irgendeiner davon zurückgegeben
werden. Wenn die Liste der übergebenen Nutzer leer ist oder keiner der übergebe-
nen Nutzer einen bekannten Kontostand hat, soll eine IllegalArgumentException
geworfen werden.
def richest(users: Iterable[User], data: BankData): User =
(e) (7 Punkte) undoLastTransaction gibt ein neues Objekt mit Kontoinformationen
zurück, in dem die letzte Transaktion rückgängig gemacht wurde. Dazu wird die
letzte Transaktion aus der Abfolge der Transaktionen entfernt und die Kontostän-
de werden entsprechend angepasst. Wenn keine letzte Transaktion existiert, wird
None zurückgegeben.
def undoLastTransaction(data: BankData): Option[BankData] =

3. Typinferenz (21 Punkte)
Im untenstehenden Scala-Codebeispiel werden zehn Variablen verschiedene Werte zu-
gewiesen. Der Scala-Compiler bestimmt den statischen Typ automatisch (Typinferenz).
case class Message(text: String, important: Boolean, attachment: Option[Any])
@main def inference(): Unit = {
val v0 = 400 + 20
val v1 = 400 + 20.0
val v2 = Message("urgent meeting", true, None)
val v3 = (text: String) => Message(text, false, None)
val v4 = Seq("buy", "my", "merch")
val v5 = v2.text.startsWith("urgent")
val v6 = v4.map(v3)
val v7 = (ms: Iterable[Message]) => ms.find(m => m.important)
val v8 = v7(v6)
val v9 = Message("totally legit code", true, Some("rm -rf *")).attachment.get
}
(a) (15 Punkte) Geben Sie für alle Variablen an, welcher statische Datentyp inferiert
wird. Beachten Sie, dass dabei auch die Typ-Parameter inferiert werden, beispiels-
weise Seq[Float] statt nur Seq. Als Antworten werden daher nur vollständige Da-
tentypen akzeptiert
(b) (2 Punkte) Welchen Wert nimmt v5 an? Welche Berechnungsschritte führen zu
diesem Wert?
(c) (2 Punkte) Welchen Wert nimmt v8 an? Welche Berechnungsschritte führen zu
diesem Wert?
(d) (2 Punkte) Welchen Wert nimmt v9 an? Welche Berechnungsschritte führen zu
diesem Wert?


4. Auflösung von Aufrufen (16 Punkte)
Die Klasse NumericFormatter im untenstehenden Codeausschnitt stellt Funktionalität
zur Formatierung von Ganzzahlen und Kommazahlen bereit. Dabei wird die Metho-
de format für beide Zahlentypen auf die einfachste erdenkliche Weise definiert: Sie
delegiert an toString. Möchte man die Formatierung anpassen, kann man die entspre-
chenden Methoden in einer Unterklasse überschreiben. Im Codebeispiel unten wird
das durch die Klasse RoundingPaddingFormatter demonstriert.
class NumericFormatter {
def format(number: Long): String = {
println("NumericFormatter.format(Long)")
number.toString
}
def format(number: Double): String = {
println("NumericFormatter.format(Double)")
if (number < 0) formatNegative(number) else formatPositive(number)
}
protected def formatPositive(number: Double): String = {
println("NumericFormatter.formatPositive(Double)")
number.toString
}
protected def formatNegative(number: Double): String = {
println("NumericFormatter.formatNegative(Double)")
"-" + formatPositive(-number)
}
}
class RoundingPaddingFormatter extends NumericFormatter {
override def format(number: Long): String = {
println("RPF.format(Long)")
val asString = super.format(number)
val padding = "." * (10 - asString.length).max(0)
padding + asString
}
override protected def formatPositive(number: Double): String = {
println("RPF.formatPositive(Double)")
number.round.toString
}
}
@main def main(): Unit = {
val formatter1: NumericFormatter = NumericFormatter()
val formatter2: NumericFormatter = RoundingPaddingFormatter()
val result1 = formatter1.format(42.2)
val result2 = formatter2.format(-42.2)
val result3 = formatter2.format(42)
}

Betrachten Sie jetzt die main-Methode.
(a) (2 Punkte) Welchen Wert nimmt result1 an?
(b) (3 Punkte) Welche Zeilen werden während der Berechnung von result1 auf der
Standardausgabe ausgegeben?
(c) (2 Punkte) Welchen Wert nimmt result2 an?
(d) (3 Punkte) Welche Zeilen werden während der Berechnung von result2 auf der
Standardausgabe ausgegeben?
(e) (3 Punkte) Welchen Wert nimmt result3 an?
(f) (3 Punkte) Welche Zeilen werden während der Berechnung von result3 auf der
Standardausgabe ausgegeben?

5. Warteschlange schreiben (21 Punkte)
Eine Warteschlange (Queue) stellt zwei Funktionen zur Verfügung: enqueue fügt ein
Element hinzu, und dequeue entfernt ein Element (und gibt es an den Aufrufer zurück).
Dabei wird das Element, was als erstes hinzugefügt wurde, auch als erstes entfernt
(First-In-First-Out). Das ist analog zur Warteschlange in der Uni-Mensa: Wer sich
zuerst anstellt, wird auch zuerst bedient.
In der Realität gibt es aber auch Situationen (Flughäfen, Freizeitparks), in denen es
zwei parallele Warteschlangen gibt: Eine normale Warteschlange und eine priorisierte
Warteschlange (fast lane). Dabei werden zuerst alle Personen bedient, die sich in der
priorisierten Warteschlange anstellen. Erst wenn diese Warteschlange leer ist, wird die
erste Person aus der normalen Warteschlange bedient.
Der Trait FastLaneQueue soll dieses Verhalten modellieren: Elemente können zur nor-
malen (enqueue) oder zur priorisierten (enqueueWithPriority) Warteschlange hinzugefügt werden. Mit headOption und dequeue kann der Nutzer auf das vorderste Element
zugreifen. Dieses Element wird immer zunächst aus der priorisierten Warteschlange
entnommen, falls dort Elemente vorhanden sind. Elemente in der priorisierten Warteschlange stehen damit effektiv vor allen Elementen in der normalen Warteschlange.
trait FastLaneQueue[A] {
/** Hängt das übergebene Element hinten an die normale Warteschlange an. */
def enqueue(e: A): Unit
/** Hängt das übergebene Element hinten an die priorisierte Warteschlange an. */
def enqueueWithPriority(e: A): Unit
/** Gibt das vorderste Element zurück, ohne es zu entfernen.
* Gibt bei leerer Warteschlange `None` zurück. */
def headOption: Option[A]
/** Entfernt das vorderste Element und gibt es zurück.
*
* @throws NoSuchElementException falls die Warteschlange leer ist
*/
def dequeue(): A
/** Gibt die Anzahl der Elemente in der Warteschlange zurück. */
def size: Int
/** Gibt das Element an der übergebenen Position in der Warteschlange zurück.
*
* Hierbei stehen priorisiert eingefügte Elemente vor den übrigen Elementen.
*
* @throws IndexOutOfBoundsException falls die Position ungültig ist
*/
def apply(index: Int): A
}

Schauen Sie sich zum besseren Verständnis das folgende Beispiel an:
@main def testQueue(): Unit = {
val queue: FastLaneQueue[Int] = EasyFastLaneQueue()
queue.enqueue(10)
queue.enqueueWithPriority(20)
queue.enqueue(30)
queue.enqueueWithPriority(40)
println(queue.dequeue()) // 20
println(queue.size) // 3
println(queue(0)) // 40
println(queue(1)) // 10
println(queue(2)) // 30
println(queue(3)) // wirft eine IndexOutOfBoundsException
}
Schreiben Sie jetzt die Klasse EasyFastLaneQueue[A], die den Trait FastLaneQueue[A]
implementiert. Sie dürfen dafür gerne Scalas mutable.Queue[A] verwenden, die im
Anhang dokumentiert ist. Beachten Sie auch die Exceptions, die in der Scaladoc-
Dokumentation beschrieben sind.
Den Anfang der Klasse haben wir Ihnen schon vorgegeben:
class EasyFastLaneQueue[A] extends FastLaneQueue[A]

6. Warteschlange verwenden (19 Punkte)
Der folgende Code-Auszug modelliert ausführbare Berechnungen (Tasks). Wir defi-
nieren einen Task als eine Funktion ohne Parameter, die eine beliebige Berechnung
ausführt und eine Rückmeldung über die ausgeführte Berechnung (TaskResult) zu-
rückgibt: War die Berechnung erfolgreich, wird eine Erfolgsmeldung zurückgegeben
(Success). Schlug die Berechnung fehl, wird ein Fehlercode zurückgegeben (Failure).
Es kann aber auch vorkommen, dass weitere Tasks ausgeführt werden müssen, um die
Berechnung abzuschließen (MoreTasks).
type Task = () => TaskResult
trait TaskResult
case class Success(message: String) extends TaskResult
case class Failure(errorCode: Int) extends TaskResult
case class MoreTasks(tasks: Seq[Task]) extends TaskResult
Die untenstehende Methode runTasks bekommt eine FastLaneQueue mit Tasks über-
geben. Die Methode soll sich den ersten Task aus der Warteschlange holen und aus-
führen. Wenn ein Task erfolgreich ausgeführt wurde, soll die zugehörige Nachricht mit
println ausgegeben werden. Wenn ein Task fehlschlägt, soll derselbe Task nochmal
in die Warteschlange aufgenommen werden (mit Priorität) und es soll der Fehlercode
mit println ausgegeben werden. Wenn ein Task weitere Tasks zurückgibt, sollen alle
neuen Tasks in die Warteschlange eingefügt werden (ohne Priorität). Dieses Verfahren
soll so lange wiederholt werden, bis die Warteschlange leer ist.
Implementieren Sie die Methode runTasks gemäß der Beschreibung.
Hinweis: Die Syntax für While-Schleifen in Scala ist while (bedingung) {operationen}.
Sie können diese Aufgabe natürlich auch ohne While-Schleife lösen.
Hinweis: Sie können diese Aufgabe auch bearbeiten, ohne die vorige Aufgabe gelöst
zu haben!
def runTasks(queue: FastLaneQueue[Task]): Unit =
